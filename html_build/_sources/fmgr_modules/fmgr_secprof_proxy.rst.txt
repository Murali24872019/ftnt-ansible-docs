==================
fmgr_secprof_proxy
==================


Metadata
--------




**Name:** fmgr_secprof_proxy

**Description:** ['Manage proxy security profiles for FortiGates via FortiManager using the FMG API with playbooks']

**Author(s):**

- Luke Weighall (github: @lweighall)

- Andrew Welsh (github: @Ghilli3)

- Jim Huber (github: @p4r4n0y1ng)



**Ansible Version Added/Required:** 2.8

**Dev Status:** PR TESTS GREEN - AWAITING APPROVAL

**Owning Developer:** Andrew Welsh

**Pull Request Started:** 10/19/18

**Days in PR:** 12

**Branch Link:** https://github.com/ftntcorecse/ansible/tree/fmgr_secprof_proxy
Parameters
----------

adom
++++

- Description: The ADOM the configuration should belong to.



- Required: False

- default: root

header_client_ip
++++++++++++++++

- Description: Actions to take on the HTTP client-IP header in forwarded requests| forwards (pass), adds, or removes the HTTP

  header.

  choice | pass | Forward the same HTTP header.

  choice | add | Add the HTTP header.

  choice | remove | Remove the HTTP header.



- Required: False

- choices: ['pass', 'add', 'remove']

header_front_end_https
++++++++++++++++++++++

- Description: Action to take on the HTTP front-end-HTTPS header in forwarded requests| forwards (pass), adds, or removes the

  HTTP header.

  choice | pass | Forward the same HTTP header.

  choice | add | Add the HTTP header.

  choice | remove | Remove the HTTP header.



- Required: False

- choices: ['pass', 'add', 'remove']

header_via_request
++++++++++++++++++

- Description: Action to take on the HTTP via header in forwarded requests| forwards (pass), adds, or removes the HTTP header

  .

  choice | pass | Forward the same HTTP header.

  choice | add | Add the HTTP header.

  choice | remove | Remove the HTTP header.



- Required: False

- choices: ['pass', 'add', 'remove']

header_via_response
+++++++++++++++++++

- Description: Action to take on the HTTP via header in forwarded responses| forwards (pass), adds, or removes the HTTP heade

  r.

  choice | pass | Forward the same HTTP header.

  choice | add | Add the HTTP header.

  choice | remove | Remove the HTTP header.



- Required: False

- choices: ['pass', 'add', 'remove']

header_x_authenticated_groups
+++++++++++++++++++++++++++++

- Description: Action to take on the HTTP x-authenticated-groups header in forwarded requests| forwards (pass), adds, or remo

  ves the HTTP header.

  choice | pass | Forward the same HTTP header.

  choice | add | Add the HTTP header.

  choice | remove | Remove the HTTP header.



- Required: False

- choices: ['pass', 'add', 'remove']

header_x_authenticated_user
+++++++++++++++++++++++++++

- Description: Action to take on the HTTP x-authenticated-user header in forwarded requests| forwards (pass), adds, or remove

  s the HTTP header.

  choice | pass | Forward the same HTTP header.

  choice | add | Add the HTTP header.

  choice | remove | Remove the HTTP header.



- Required: False

- choices: ['pass', 'add', 'remove']

header_x_forwarded_for
++++++++++++++++++++++

- Description: Action to take on the HTTP x-forwarded-for header in forwarded requests| forwards (pass), adds, or removes the

  HTTP header.

  choice | pass | Forward the same HTTP header.

  choice | add | Add the HTTP header.

  choice | remove | Remove the HTTP header.



- Required: False

- choices: ['pass', 'add', 'remove']

headers
+++++++

- Description: EXPERTS ONLY! KNOWLEDGE OF FMGR JSON API IS REQUIRED!

  List of multiple child objects to be added. Expects a list of dictionaries.

  Dictionaries must use FortiManager API parameters, not the ansible ones listed below.

  If submitted, all other prefixed sub-parameters ARE IGNORED.

  This object is MUTUALLY EXCLUSIVE with its options.

  We expect that you know what you are doing with these list parameters, and are leveraging the JSON API Guide.

  WHEN IN DOUBT, USE THE SUB OPTIONS BELOW INSTEAD TO CREATE OBJECTS WITH MULTIPLE TASKS



- Required: False

headers_action
++++++++++++++

- Description: Action when HTTP the header forwarded.

  choice | add-to-request | Add the HTTP header to request.

  choice | add-to-response | Add the HTTP header to response.

  choice | remove-from-request | Remove the HTTP header from request.

  choice | remove-from-response | Remove the HTTP header from response.



- Required: False

- choices: ['add-to-request', 'add-to-response', 'remove-from-request', 'remove-from-response']

headers_content
+++++++++++++++

- Description: HTTP header's content.



- Required: False

headers_name
++++++++++++

- Description: HTTP forwarded header name.



- Required: False

host
++++

- Description: The FortiManager's Address.



- Required: True

log_header_change
+++++++++++++++++

- Description: Enable/disable logging HTTP header changes.

  choice | disable | Disable Enable/disable logging HTTP header changes.

  choice | enable | Enable Enable/disable logging HTTP header changes.



- Required: False

- choices: ['disable', 'enable']

mode
++++

- Description: Sets one of three modes for managing the object.

  Allows use of soft-adds instead of overwriting existing values



- Required: False

- default: add

- choices: ['add', 'set', 'delete', 'update']

name
++++

- Description: Profile name.



- Required: False

password
++++++++

- Description: The password associated with the username account.



- Required: True

strip_encoding
++++++++++++++

- Description: Enable/disable stripping unsupported encoding from the request header.

  choice | disable | Disable stripping of unsupported encoding from the request header.

  choice | enable | Enable stripping of unsupported encoding from the request header.



- Required: False

- choices: ['disable', 'enable']

username
++++++++

- Description: The username associated with the account.



- Required: True




Functions
---------




- fmgr_web_proxy_profile_addsetdelete

 .. code-block:: python

    def fmgr_web_proxy_profile_addsetdelete(fmg, paramgram):
        """
        fmgr_web_proxy_profile -- Your Description here, bruh
        """

        mode = paramgram["mode"]
        adom = paramgram["adom"]

        response = (-100000, {"msg": "Illegal or malformed paramgram discovered. System Exception"})
        url = ""
        datagram = {}

        # EVAL THE MODE PARAMETER FOR SET OR ADD
        if mode in ['set', 'add', 'update']:
            url = '/pm/config/adom/{adom}/obj/web-proxy/profile'.format(adom=adom)
            datagram = fmgr_del_none(fmgr_prepare_dict(paramgram))

        # EVAL THE MODE PARAMETER FOR DELETE
        elif mode == "delete":
            # SET THE CORRECT URL FOR DELETE
            url = '/pm/config/adom/{adom}/obj/web-proxy/profile/{name}'.format(adom=adom, name=paramgram["name"])
            datagram = {}

        # IF MODE = SET -- USE THE 'SET' API CALL MODE
        if mode == "set":
            response = fmg.set(url, datagram)
        # IF MODE = UPDATE -- USER THE 'UPDATE' API CALL MODE
        elif mode == "update":
            response = fmg.update(url, datagram)
        # IF MODE = ADD  -- USE THE 'ADD' API CALL MODE
        elif mode == "add":
            response = fmg.add(url, datagram)
        # IF MODE = DELETE  -- USE THE DELETE URL AND API CALL MODE
        elif mode == "delete":
            response = fmg.delete(url, datagram)

        return response


    # ADDITIONAL COMMON FUNCTIONS

- fmgr_logout

 .. code-block:: python

    def fmgr_logout(fmg, module, msg="NULL", results=(), good_codes=(0,), logout_on_fail=True, logout_on_success=False):
        """
        THIS METHOD CONTROLS THE LOGOUT AND ERROR REPORTING AFTER AN METHOD OR FUNCTION RUNS
        """
        # VALIDATION ERROR (NO RESULTS, JUST AN EXIT)
        if msg != "NULL" and len(results) == 0:
            try:
                fmg.logout()
            except:
                pass
            module.fail_json(msg=msg)

        # SUBMISSION ERROR
        if len(results) > 0:
            if msg == "NULL":
                try:
                    msg = results[1]['status']['message']
                except:
                    msg = "No status message returned from pyFMG. Possible that this was a GET with a tuple result."

            if results[0] not in good_codes:
                if logout_on_fail:
                    fmg.logout()
                    module.fail_json(msg=msg, **results[1])
            else:
                if logout_on_success:
                    fmg.logout()
                    module.exit_json(msg="API Called worked, but logout handler has been asked to logout on success",
                                     **results[1])
        return msg


    # FUNCTION/METHOD FOR CONVERTING CIDR TO A NETMASK
    # DID NOT USE IP ADDRESS MODULE TO KEEP INCLUDES TO A MINIMUM

- fmgr_cidr_to_netmask

 .. code-block:: python

    def fmgr_cidr_to_netmask(cidr):
        cidr = int(cidr)
        mask = (0xffffffff >> (32 - cidr)) << (32 - cidr)
        return(str((0xff000000 & mask) >> 24) + '.' +
               str((0x00ff0000 & mask) >> 16) + '.' +
               str((0x0000ff00 & mask) >> 8) + '.' +
               str((0x000000ff & mask)))


    # utility function: removing keys wih value of None, nothing in playbook for that key

- fmgr_del_none

 .. code-block:: python

    def fmgr_del_none(obj):
        if isinstance(obj, dict):
            return type(obj)((fmgr_del_none(k), fmgr_del_none(v))
                             for k, v in obj.items() if k is not None and (v is not None and not fmgr_is_empty_dict(v)))
        else:
            return obj


    # utility function: remove keys that are need for the logic but the FMG API won't accept them

- fmgr_prepare_dict

 .. code-block:: python

    def fmgr_prepare_dict(obj):
        list_of_elems = ["mode", "adom", "host", "username", "password"]
        if isinstance(obj, dict):
            obj = dict((key, fmgr_prepare_dict(value)) for (key, value) in obj.items() if key not in list_of_elems)
        return obj



- fmgr_is_empty_dict

 .. code-block:: python

    def fmgr_is_empty_dict(obj):
        return_val = False
        if isinstance(obj, dict):
            if len(obj) > 0:
                for k, v in obj.items():
                    if isinstance(v, dict):
                        if len(v) == 0:
                            return_val = True
                        elif len(v) > 0:
                            for k1, v1 in v.items():
                                if v1 is None:
                                    return_val = True
                                elif v1 is not None:
                                    return_val = False
                                    return return_val
                    elif v is None:
                        return_val = True
                    elif v is not None:
                        return_val = False
                        return return_val
            elif len(obj) == 0:
                return_val = True

        return return_val



- fmgr_split_comma_strings_into_lists

 .. code-block:: python

    def fmgr_split_comma_strings_into_lists(obj):
        if isinstance(obj, dict):
            if len(obj) > 0:
                for k, v in obj.items():
                    if isinstance(v, str):
                        new_list = list()
                        if "," in v:
                            new_items = v.split(",")
                            for item in new_items:
                                new_list.append(item.strip())
                            obj[k] = new_list

        return obj


    #############
    # END METHODS
    #############



- main

 .. code-block:: python

    def main():
        argument_spec = dict(
            adom=dict(type="str", default="root"),
            host=dict(required=True, type="str"),
            password=dict(fallback=(env_fallback, ["ANSIBLE_NET_PASSWORD"]), no_log=True, required=True),
            username=dict(fallback=(env_fallback, ["ANSIBLE_NET_USERNAME"]), no_log=True, required=True),
            mode=dict(choices=["add", "set", "delete", "update"], type="str", default="add"),

            strip_encoding=dict(required=False, type="str", choices=["disable", "enable"]),
            name=dict(required=False, type="str"),
            log_header_change=dict(required=False, type="str", choices=["disable", "enable"]),
            header_x_forwarded_for=dict(required=False, type="str", choices=["pass", "add", "remove"]),
            header_x_authenticated_user=dict(required=False, type="str", choices=["pass", "add", "remove"]),
            header_x_authenticated_groups=dict(required=False, type="str", choices=["pass", "add", "remove"]),
            header_via_response=dict(required=False, type="str", choices=["pass", "add", "remove"]),
            header_via_request=dict(required=False, type="str", choices=["pass", "add", "remove"]),
            header_front_end_https=dict(required=False, type="str", choices=["pass", "add", "remove"]),
            header_client_ip=dict(required=False, type="str", choices=["pass", "add", "remove"]),
            headers=dict(required=False, type="list"),
            headers_action=dict(required=False, type="str", choices=["add-to-request", "add-to-response",
                                                                     "remove-from-request", "remove-from-response"]),
            headers_content=dict(required=False, type="str"),
            headers_name=dict(required=False, type="str"),

        )

        module = AnsibleModule(argument_spec, supports_check_mode=False)

        # MODULE PARAMGRAM
        paramgram = {
            "mode": module.params["mode"],
            "adom": module.params["adom"],
            "strip-encoding": module.params["strip_encoding"],
            "name": module.params["name"],
            "log-header-change": module.params["log_header_change"],
            "header-x-forwarded-for": module.params["header_x_forwarded_for"],
            "header-x-authenticated-user": module.params["header_x_authenticated_user"],
            "header-x-authenticated-groups": module.params["header_x_authenticated_groups"],
            "header-via-response": module.params["header_via_response"],
            "header-via-request": module.params["header_via_request"],
            "header-front-end-https": module.params["header_front_end_https"],
            "header-client-ip": module.params["header_client_ip"],
            "headers": {
                "action": module.params["headers_action"],
                "content": module.params["headers_content"],
                "name": module.params["headers_name"],
            }
        }

        list_overrides = ['headers']
        for list_variable in list_overrides:
            override_data = list()
            try:
                override_data = module.params[list_variable]
            except:
                pass
            try:
                if override_data:
                    del paramgram[list_variable]
                    paramgram[list_variable] = override_data
            except:
                pass

        # CHECK IF THE HOST/USERNAME/PW EXISTS, AND IF IT DOES, LOGIN.
        host = module.params["host"]
        password = module.params["password"]
        username = module.params["username"]
        if host is None or username is None or password is None:
            module.fail_json(msg="Host and username and password are required")

        # CHECK IF LOGIN FAILED
        fmg = AnsibleFortiManager(module, module.params["host"], module.params["username"], module.params["password"])

        response = fmg.login()
        if response[1]['status']['code'] != 0:
            module.fail_json(msg="Connection to FortiManager Failed")

        results = fmgr_web_proxy_profile_addsetdelete(fmg, paramgram)
        if results[0] != 0:
            fmgr_logout(fmg, module, results=results, good_codes=[0])

        fmg.logout()

        if results is not None:
            return module.exit_json(**results[1])
        else:
            return module.exit_json(msg="No results were returned from the API call.")





Module Source Code
------------------

.. code-block:: python

    #!/usr/bin/python
    #
    # This file is part of Ansible
    #
    # Ansible is free software: you can redistribute it and/or modify
    # it under the terms of the GNU General Public License as published by
    # the Free Software Foundation, either version 3 of the License, or
    # (at your option) any later version.
    #
    # Ansible is distributed in the hope that it will be useful,
    # but WITHOUT ANY WARRANTY; without even the implied warranty of
    # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    # GNU General Public License for more details.
    #
    # You should have received a copy of the GNU General Public License
    # along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
    #

    from __future__ import absolute_import, division, print_function
    __metaclass__ = type

    ANSIBLE_METADATA = {'status': ['preview'],
                        'supported_by': 'community',
                        'metadata_version': '1.1'}

    DOCUMENTATION = '''
    ---
    module: fmgr_secprof_proxy
    version_added: "2.8"
    author:
        - Luke Weighall (@lweighall)
        - Andrew Welsh (@Ghilli3)
        - Jim Huber (@p4r4n0y1ng)
    short_description: Manage proxy security profiles in FortiManager
    description:
      -  Manage proxy security profiles for FortiGates via FortiManager using the FMG API with playbooks

    options:
      adom:
        description:
          - The ADOM the configuration should belong to.
        required: false
        default: root

      host:
        description:
          - The FortiManager's Address.
        required: true

      username:
        description:
          - The username associated with the account.
        required: true

      password:
        description:
          - The password associated with the username account.
        required: true

      mode:
        description:
          - Sets one of three modes for managing the object.
          - Allows use of soft-adds instead of overwriting existing values
        choices: ['add', 'set', 'delete', 'update']
        required: false
        default: add

      strip_encoding:
        description:
          - Enable/disable stripping unsupported encoding from the request header.
          - choice | disable | Disable stripping of unsupported encoding from the request header.
          - choice | enable | Enable stripping of unsupported encoding from the request header.
        required: false
        choices: ["disable", "enable"]

      name:
        description:
          - Profile name.
        required: false

      log_header_change:
        description:
          - Enable/disable logging HTTP header changes.
          - choice | disable | Disable Enable/disable logging HTTP header changes.
          - choice | enable | Enable Enable/disable logging HTTP header changes.
        required: false
        choices: ["disable", "enable"]

      header_x_forwarded_for:
        description:
          - Action to take on the HTTP x-forwarded-for header in forwarded requests| forwards (pass), adds, or removes the
          -  HTTP header.
          - choice | pass | Forward the same HTTP header.
          - choice | add | Add the HTTP header.
          - choice | remove | Remove the HTTP header.
        required: false
        choices: ["pass", "add", "remove"]

      header_x_authenticated_user:
        description:
          - Action to take on the HTTP x-authenticated-user header in forwarded requests| forwards (pass), adds, or remove
          - s the HTTP header.
          - choice | pass | Forward the same HTTP header.
          - choice | add | Add the HTTP header.
          - choice | remove | Remove the HTTP header.
        required: false
        choices: ["pass", "add", "remove"]

      header_x_authenticated_groups:
        description:
          - Action to take on the HTTP x-authenticated-groups header in forwarded requests| forwards (pass), adds, or remo
          - ves the HTTP header.
          - choice | pass | Forward the same HTTP header.
          - choice | add | Add the HTTP header.
          - choice | remove | Remove the HTTP header.
        required: false
        choices: ["pass", "add", "remove"]

      header_via_response:
        description:
          - Action to take on the HTTP via header in forwarded responses| forwards (pass), adds, or removes the HTTP heade
          - r.
          - choice | pass | Forward the same HTTP header.
          - choice | add | Add the HTTP header.
          - choice | remove | Remove the HTTP header.
        required: false
        choices: ["pass", "add", "remove"]

      header_via_request:
        description:
          - Action to take on the HTTP via header in forwarded requests| forwards (pass), adds, or removes the HTTP header
          - .
          - choice | pass | Forward the same HTTP header.
          - choice | add | Add the HTTP header.
          - choice | remove | Remove the HTTP header.
        required: false
        choices: ["pass", "add", "remove"]

      header_front_end_https:
        description:
          - Action to take on the HTTP front-end-HTTPS header in forwarded requests| forwards (pass), adds, or removes the
          -  HTTP header.
          - choice | pass | Forward the same HTTP header.
          - choice | add | Add the HTTP header.
          - choice | remove | Remove the HTTP header.
        required: false
        choices: ["pass", "add", "remove"]

      header_client_ip:
        description:
          - Actions to take on the HTTP client-IP header in forwarded requests| forwards (pass), adds, or removes the HTTP
          -  header.
          - choice | pass | Forward the same HTTP header.
          - choice | add | Add the HTTP header.
          - choice | remove | Remove the HTTP header.
        required: false
        choices: ["pass", "add", "remove"]

      headers:
        description:
          - EXPERTS ONLY! KNOWLEDGE OF FMGR JSON API IS REQUIRED!
          - List of multiple child objects to be added. Expects a list of dictionaries.
          - Dictionaries must use FortiManager API parameters, not the ansible ones listed below.
          - If submitted, all other prefixed sub-parameters ARE IGNORED.
          - This object is MUTUALLY EXCLUSIVE with its options.
          - We expect that you know what you are doing with these list parameters, and are leveraging the JSON API Guide.
          - WHEN IN DOUBT, USE THE SUB OPTIONS BELOW INSTEAD TO CREATE OBJECTS WITH MULTIPLE TASKS
        required: false

      headers_action:
        description:
          - Action when HTTP the header forwarded.
          - choice | add-to-request | Add the HTTP header to request.
          - choice | add-to-response | Add the HTTP header to response.
          - choice | remove-from-request | Remove the HTTP header from request.
          - choice | remove-from-response | Remove the HTTP header from response.
        required: false
        choices: ["add-to-request", "add-to-response", "remove-from-request", "remove-from-response"]

      headers_content:
        description:
          - HTTP header's content.
        required: false

      headers_name:
        description:
          - HTTP forwarded header name.
        required: false


    '''

    EXAMPLES = '''
      - name: DELETE Profile
        fmgr_secprof_proxy:
          host: "{{inventory_hostname}}"
          username: "{{ username }}"
          password: "{{ password }}"
          name: "Ansible_Web_Proxy_Profile"
          mode: "delete"

      - name: CREATE Profile
        fmgr_secprof_proxy:
          host: "{{inventory_hostname}}"
          username: "{{ username }}"
          password: "{{ password }}"
          name: "Ansible_Web_Proxy_Profile"
          mode: "set"
          header_client_ip: "pass"
          header_front_end_https: "add"
          header_via_request: "remove"
          header_via_response: "pass"
          header_x_authenticated_groups: "add"
          header_x_authenticated_user: "remove"
          strip_encoding: "enable"
          log_header_change: "enable"
          header_x_forwarded_for: "pass"
          headers_action: "add-to-request"
          headers_content: "test"
          headers_name: "test_header"
    '''

    RETURN = """
    api_result:
      description: full API response, includes status code and message
      returned: always
      type: string
    """

    from ansible.module_utils.basic import AnsibleModule, env_fallback
    from ansible.module_utils.network.fortimanager.fortimanager import AnsibleFortiManager

    # check for pyFMG lib
    try:
        from pyFMG.fortimgr import FortiManager
        HAS_PYFMGR = True
    except ImportError:
        HAS_PYFMGR = False

    ###############
    # START METHODS
    ###############


    def fmgr_web_proxy_profile_addsetdelete(fmg, paramgram):
        """
        fmgr_web_proxy_profile -- Your Description here, bruh
        """

        mode = paramgram["mode"]
        adom = paramgram["adom"]

        response = (-100000, {"msg": "Illegal or malformed paramgram discovered. System Exception"})
        url = ""
        datagram = {}

        # EVAL THE MODE PARAMETER FOR SET OR ADD
        if mode in ['set', 'add', 'update']:
            url = '/pm/config/adom/{adom}/obj/web-proxy/profile'.format(adom=adom)
            datagram = fmgr_del_none(fmgr_prepare_dict(paramgram))

        # EVAL THE MODE PARAMETER FOR DELETE
        elif mode == "delete":
            # SET THE CORRECT URL FOR DELETE
            url = '/pm/config/adom/{adom}/obj/web-proxy/profile/{name}'.format(adom=adom, name=paramgram["name"])
            datagram = {}

        # IF MODE = SET -- USE THE 'SET' API CALL MODE
        if mode == "set":
            response = fmg.set(url, datagram)
        # IF MODE = UPDATE -- USER THE 'UPDATE' API CALL MODE
        elif mode == "update":
            response = fmg.update(url, datagram)
        # IF MODE = ADD  -- USE THE 'ADD' API CALL MODE
        elif mode == "add":
            response = fmg.add(url, datagram)
        # IF MODE = DELETE  -- USE THE DELETE URL AND API CALL MODE
        elif mode == "delete":
            response = fmg.delete(url, datagram)

        return response


    # ADDITIONAL COMMON FUNCTIONS
    def fmgr_logout(fmg, module, msg="NULL", results=(), good_codes=(0,), logout_on_fail=True, logout_on_success=False):
        """
        THIS METHOD CONTROLS THE LOGOUT AND ERROR REPORTING AFTER AN METHOD OR FUNCTION RUNS
        """
        # VALIDATION ERROR (NO RESULTS, JUST AN EXIT)
        if msg != "NULL" and len(results) == 0:
            try:
                fmg.logout()
            except:
                pass
            module.fail_json(msg=msg)

        # SUBMISSION ERROR
        if len(results) > 0:
            if msg == "NULL":
                try:
                    msg = results[1]['status']['message']
                except:
                    msg = "No status message returned from pyFMG. Possible that this was a GET with a tuple result."

            if results[0] not in good_codes:
                if logout_on_fail:
                    fmg.logout()
                    module.fail_json(msg=msg, **results[1])
            else:
                if logout_on_success:
                    fmg.logout()
                    module.exit_json(msg="API Called worked, but logout handler has been asked to logout on success",
                                     **results[1])
        return msg


    # FUNCTION/METHOD FOR CONVERTING CIDR TO A NETMASK
    # DID NOT USE IP ADDRESS MODULE TO KEEP INCLUDES TO A MINIMUM
    def fmgr_cidr_to_netmask(cidr):
        cidr = int(cidr)
        mask = (0xffffffff >> (32 - cidr)) << (32 - cidr)
        return(str((0xff000000 & mask) >> 24) + '.' +
               str((0x00ff0000 & mask) >> 16) + '.' +
               str((0x0000ff00 & mask) >> 8) + '.' +
               str((0x000000ff & mask)))


    # utility function: removing keys wih value of None, nothing in playbook for that key
    def fmgr_del_none(obj):
        if isinstance(obj, dict):
            return type(obj)((fmgr_del_none(k), fmgr_del_none(v))
                             for k, v in obj.items() if k is not None and (v is not None and not fmgr_is_empty_dict(v)))
        else:
            return obj


    # utility function: remove keys that are need for the logic but the FMG API won't accept them
    def fmgr_prepare_dict(obj):
        list_of_elems = ["mode", "adom", "host", "username", "password"]
        if isinstance(obj, dict):
            obj = dict((key, fmgr_prepare_dict(value)) for (key, value) in obj.items() if key not in list_of_elems)
        return obj


    def fmgr_is_empty_dict(obj):
        return_val = False
        if isinstance(obj, dict):
            if len(obj) > 0:
                for k, v in obj.items():
                    if isinstance(v, dict):
                        if len(v) == 0:
                            return_val = True
                        elif len(v) > 0:
                            for k1, v1 in v.items():
                                if v1 is None:
                                    return_val = True
                                elif v1 is not None:
                                    return_val = False
                                    return return_val
                    elif v is None:
                        return_val = True
                    elif v is not None:
                        return_val = False
                        return return_val
            elif len(obj) == 0:
                return_val = True

        return return_val


    def fmgr_split_comma_strings_into_lists(obj):
        if isinstance(obj, dict):
            if len(obj) > 0:
                for k, v in obj.items():
                    if isinstance(v, str):
                        new_list = list()
                        if "," in v:
                            new_items = v.split(",")
                            for item in new_items:
                                new_list.append(item.strip())
                            obj[k] = new_list

        return obj


    #############
    # END METHODS
    #############


    def main():
        argument_spec = dict(
            adom=dict(type="str", default="root"),
            host=dict(required=True, type="str"),
            password=dict(fallback=(env_fallback, ["ANSIBLE_NET_PASSWORD"]), no_log=True, required=True),
            username=dict(fallback=(env_fallback, ["ANSIBLE_NET_USERNAME"]), no_log=True, required=True),
            mode=dict(choices=["add", "set", "delete", "update"], type="str", default="add"),

            strip_encoding=dict(required=False, type="str", choices=["disable", "enable"]),
            name=dict(required=False, type="str"),
            log_header_change=dict(required=False, type="str", choices=["disable", "enable"]),
            header_x_forwarded_for=dict(required=False, type="str", choices=["pass", "add", "remove"]),
            header_x_authenticated_user=dict(required=False, type="str", choices=["pass", "add", "remove"]),
            header_x_authenticated_groups=dict(required=False, type="str", choices=["pass", "add", "remove"]),
            header_via_response=dict(required=False, type="str", choices=["pass", "add", "remove"]),
            header_via_request=dict(required=False, type="str", choices=["pass", "add", "remove"]),
            header_front_end_https=dict(required=False, type="str", choices=["pass", "add", "remove"]),
            header_client_ip=dict(required=False, type="str", choices=["pass", "add", "remove"]),
            headers=dict(required=False, type="list"),
            headers_action=dict(required=False, type="str", choices=["add-to-request", "add-to-response",
                                                                     "remove-from-request", "remove-from-response"]),
            headers_content=dict(required=False, type="str"),
            headers_name=dict(required=False, type="str"),

        )

        module = AnsibleModule(argument_spec, supports_check_mode=False)

        # MODULE PARAMGRAM
        paramgram = {
            "mode": module.params["mode"],
            "adom": module.params["adom"],
            "strip-encoding": module.params["strip_encoding"],
            "name": module.params["name"],
            "log-header-change": module.params["log_header_change"],
            "header-x-forwarded-for": module.params["header_x_forwarded_for"],
            "header-x-authenticated-user": module.params["header_x_authenticated_user"],
            "header-x-authenticated-groups": module.params["header_x_authenticated_groups"],
            "header-via-response": module.params["header_via_response"],
            "header-via-request": module.params["header_via_request"],
            "header-front-end-https": module.params["header_front_end_https"],
            "header-client-ip": module.params["header_client_ip"],
            "headers": {
                "action": module.params["headers_action"],
                "content": module.params["headers_content"],
                "name": module.params["headers_name"],
            }
        }

        list_overrides = ['headers']
        for list_variable in list_overrides:
            override_data = list()
            try:
                override_data = module.params[list_variable]
            except:
                pass
            try:
                if override_data:
                    del paramgram[list_variable]
                    paramgram[list_variable] = override_data
            except:
                pass

        # CHECK IF THE HOST/USERNAME/PW EXISTS, AND IF IT DOES, LOGIN.
        host = module.params["host"]
        password = module.params["password"]
        username = module.params["username"]
        if host is None or username is None or password is None:
            module.fail_json(msg="Host and username and password are required")

        # CHECK IF LOGIN FAILED
        fmg = AnsibleFortiManager(module, module.params["host"], module.params["username"], module.params["password"])

        response = fmg.login()
        if response[1]['status']['code'] != 0:
            module.fail_json(msg="Connection to FortiManager Failed")

        results = fmgr_web_proxy_profile_addsetdelete(fmg, paramgram)
        if results[0] != 0:
            fmgr_logout(fmg, module, results=results, good_codes=[0])

        fmg.logout()

        if results is not None:
            return module.exit_json(**results[1])
        else:
            return module.exit_json(msg="No results were returned from the API call.")


    if __name__ == "__main__":
        main()


